# 2022-01-19 memo

https://sunpro.io/techbookfest/hakatashi.html

楽しく読んだ。

ちょっと面白かったのが、 initiator が ClientHello を送るのは TCP ハンドシェイクを終える ACK を送って本当にすぐであって、なんならその ACK が相手に届くよりも前にさえなりうる、というところ。
あと、100 KB のデータを送る最後のセグメントをサーバが送出する瞬間には6割くらいまでの分しか ACK を受け取ってなくて、残り4割は経路上にあるというのも。
ふーむ、どちらも光の遅さから来てるのがまた面白い。
この2点、インターネットの現象を見るときはいつも注目しているレイヤーだけに集中してて、上下のレイヤーを横断するタイムラインなんて追ってないから、新鮮に感じるんだろうな。
そうやって、普段は見なくていいところ見ないで考えることを減らせるのは、レイヤーによるモデリングで抽象化がうまくいってる勝利なわけだけど。

## 気になったところ (1) TLS レコードプロトコルの影響

Disclaimer: 以下の記述は元の記事と RFC を読んで解釈したものであり、検証は一切行っていない。

HTTP レスポンスを送るのに71個の TCP セグメントが必要というくだり、 TLS レコードプロトコルの影響を考慮し忘れてると思う。
「 TLS のレコードは平文の断片にして16 KiB が最大サイズ」 (Section 6.2.1 of \[RFC5246])であり、「レコードごとに5バイト(上位層プロトコルの type に1バイト + TLS プロトコルバージョンに2バイト + 断片の長さに2バイト)」 (Section 6.2 of \[RFC5246])のヘッダがある。
あと考慮すべき影響は、圧縮と(今回の場合)認証付き暗号。
CRIME 攻撃があって以降 TLS のレイヤーにおける圧縮は使われていないはずで、「 AEAD\_AES\_256\_GCM による暗号文は平文より正確に16オクテット長い」 (Section 5.1 &amp; 5.2 of \[RFC5116])。
以上を合わせて、 TCP ストリームを流れるレコードは平文16 KiB あたり5 bytes + 16 KiB + 16 bytes (= 16405 bytes)の大きさになっている、はず。
平文が「100 KiB プラス HTTP ヘッダ」だから、レコードは7個で足りるかな。
まあ、 TLS のレコードが16 KiB と案外長かったので、21バイトのオーバーヘッドは0.1%にしかならないわけだけど。

## 気になったところ (2) サーバからの TLS closure alert

HTTP レスポンスを運ぶ最後の71番目のパケットには TLS の closure alert も入ってるはず、というのを明示してほしかった。
もし仮に、最後の TCP セグメントに FIN フラグが立っているだけだとするなら、この記事自身も言っている truncation attack との区別がつかないはずだ。

面白いことに TCP, TLS, HTTP すべてに共通の性質として、サーバ・クライアントのいずれからも「自分はこれ以上データを送らない」と宣言できる機能がある: TCP においては FIN フラグ、 TLS では closure alert 、 HTTP では `Connection: close` ヘッダ。
以下、私の解釈を示す。

- まず、上位層の HTTP のリクエストは curl によって行われ、 curl はその接続を使うのがコマンドラインで指定されるちょうど1つの GET リクエストのみであると認識できる。そのため、その GET リクエストに `Connection: close` ヘッダを含めたのだろう。
- そのリクエストを受信したサーバは Section 6.6 of \[RFC7230] に従い、その接続でただ1つとなるレスポンスに `Connection: close` を含め、書き込み側だけを閉じて接続を half-close とする。
- サーバの HTTP の下層にいるのは TLS であり、 TLS はこの half-close を実現するものとして close\_notify を送るはず。なお、 close\_notify メッセージは、レコード層のオーバーヘッド21バイトに加えてたった2バイトと小さいもの。
- (Section 7.2.1 of [RFC5246] はもやっとしたことを言ってるけど、)常識的に構成された環境なら、 TLS の書き込み側を閉じるなら基礎になる TCP も half-close に閉じるはずで、これが元の記事でも言っている FIN フラグなんだろう。
- そうやって、「 GET へのレスポンスの末端を含む TLS レコードの末尾と close\_notify レコードを含みながら、 FIN フラグも立っている」71番目のセグメントが送られたのだろう。
- クライアント側でも、まず curl が GET へのレスポンスが終わったことを認識して、接続を閉じようとする。
- (それとは実は独立に、)クライアントが close\_notify を送る理由は、元の記事が言う「FINパケットを受け取った」からではなく、(元の記事で見落とされた) close\_notify を受け取ったからのはずだ(Section 7.2.1 \[MUST] of \[RFC5246])。
- 例えばサーバの CPU が絶望的に混んでるかあるいは何かのタイミングによっては、71番目の TCP セグメントは close\_notify を含むけど FIN フラグは立ってなくて、その次のセグメントで FIN フラグを送ったかもしれない。仮にそうなれば、前者によって TLS の切断・後者によって TCP の切断と、分かれて観測されたかもしれない。
- クライアントから TLS を閉じる close\_notify のセグメントと、 TCP の passive close である FIN セグメントが分かれて送られてるのは何か理由があるんだろうか？　サーバ側と同じように1つのセグメントにまとめても問題ない気がするけど。ともあれ、 TCP 4-way close の後半は元の記事のとおり。

## あと一つ

TCP の視点だと今回はサーバが active close の立場なので、 TIME\_WAIT 状態の4つ組が実時間で数十秒、元の記事の例えだと数十年ほど残ることに……　このスケールだと長い……

## おわりに

長々とダメ出しをしてきたわけだけど、元の記事のうち L2 ～ L4 と TLS ハンドシェイクについて私は違和感がなかった・誤りを見つけはしなかった。
TLS 層の記述にだけ違和感があったわけで、邪推ではあるけど、著者はパケットキャプチャの全体よりは各セグメントのヘッダに集中してたんじゃないかな。
私が気づいた TLS レコードプロトコルのオーバーヘッドや close\_notify レコードといった、元の記事で見落とされた要素はどちらも小さかったので、「 TCP セグメントは71個だった」という点には影響がなかったんだろう。

いつもはやらない視点でレイヤーを上下していろいろな RFC を読み、たいへん勉強になった。

## 参考文献

- [RFC5246]  Dierks, T. and E. Rescorla, \`\`The Transport Layer Security (TLS) Protocol Version 1.2", RFC 5246, August 2008.
- [RFC5116]  D. McGrew, \`\`An Interface and Algorithms for Authenticated Encryption", RFC 5116, January 2008.
- [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., \`\`Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing", RFC 7230, June 2014.
