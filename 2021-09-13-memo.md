# 2021-09-13 memo

(前提となる知識がわりと多いので、このメモを self-contained にする努力はしていない。ご容赦を)

https://github.com/fosslinux/live-bootstrap/blob/master/parts.rst via https://twitter.com/EzoeRyou/status/1429720956847595520

いやあ、たいへん面白かった。

## live-bootstrap と関連プロジェクト

残念ながら機会がなくてまだ試してないんだけど、 GNU Guix は日常的に使える程度に豊かなユーザランドを持ちながら、おそらくもっとも [bootstrappable builds](https://bootstrappable.org/) に注力している Linux ディストリビューションだ。
Guix でユーザランドをブートストラップするのに必要なバイナリシードは去年[削減され](https://guix.gnu.org/en/blog/2020/guix-further-reduces-bootstrap-seed-to-25/) て、(適当な Linux カーネルが別に必要なのを除けば) GNU Mes + mescc-tools + GNU Guile の合わせて~60 MiB になった、とこれは少し前に知っためでたいニュース。
今回驚いたのは次の2点:

- live-bootstrap というプロジェクトが Guix とは別のアプローチで興味深いところまで到達していたのを見たこと。
- (進捗を楽しみにしていながらも)しばらく見ていないうちに、下記の [mes-m2](https://github.com/oriansj/mes-m2) が他のプロジェクトの基盤になれたところまでその完成度を上げていたこと。

俺の理解では:

- Guix は [reproducible builds](https://reproducible-builds.org/) からスタートして、上向きには様々なパッケージのビルド手順を開発してディストリビューションとしての魅力を高め、基盤に向かっては Mes などの開発を通じて徐々にバイナリシードを減らしてきた。
- live-bootstrap は、極限まで小さいバイナリシード (hex0-seed と kaem-optional-seed を合わせて 1-2 KiB) から始めて、現状は最低限 Linux システムとして起動できるところまで。初期のステップに stage0-posix と mes-m2 を含む。

といった出発点の違いがある、と思う。
ついでに関連する他のプロジェクトの俺の理解を足しておくと:

- stage0: 極小のバイナリシードから C のサブセットのコンパイラ `cc_*` などまでをブートストラップするプロジェクト。
- Mes: C で 5000行くらいで書かれた小さい Scheme インタプリタ Mes と、 Scheme で書かれた C コンパイラ MesCC の組み合わせ。 MesCC はいろいろ工夫すると tinycc をコンパイルできる能力があり、 tcc もいろいろがんばると古い GCC をコンパイルできる、古い GCC はより新しい GCC をコンパイルできる。ということで、 Guix のバイナリシードから GNU ビルドシステムを取り除いた功労者。立ち位置としては Guix のスピンアウト、でいいのかなあ？
- M2-Planet: C のサブセットで書かれた C のサブセットのコンパイラ。特に、 stage0 の `cc_*` でコンパイルできるのがポイント。
- stage0-posix: stage0 の POSIX 環境への移植、と M2-Planet (とあと mescc-tools-extra) のセット。 live-bootstrap の一番最初のステップにあたる。
- mes-m2: さて、 stage0-posix は極小のバイナリシードから M2-Planet をブートストラップできる。そして、 Mes はたかだか5000行の C でしかない。となれば、 Mes を M2-Planet に移植すれば、極小のバイナリシードから GCC などに至る長いブートストラップの鎖がようやく完成する。それをやるプロジェクト。 live-bootstrap の一部としてその早い段階で、 M2-Planet によってコンパイルされる。それが実現したということは、 mes-m2 は当初の目的を達成したということだよなあ、めでたい。

## 現状どこまで届くのさ？

一連のスレッドは https://twitter.com/EzoeRyou/status/1429733387560882176 と締められているが、この時点での[デフォルトブランチ](https://github.com/fosslinux/live-bootstrap/tree/f9ebb331680b4d4e2f16b5c401f143fdd62b0e0a) はある程度いい区切りがついていると俺は思う。
あくまでソースや CI のレポートなどを読んだだけでどのコード片も自分では走らせていない推測だけど: それなりの CPU とメモリ4-8 GiB を備えたマシン上で(推測するに)1-3時間ほどかけて起動し、 x86_64-unknown-linux-musl な GCC 4.7.4 と GNU Bash 5.1 がビルドされた状態で Bash の対話プロンプトが出てきておしまい、と読めた。
追加のソースコードパッケージを含めるよう数行書き足せば、手でその先を `configure && make && make install` なんて走らせられそうな、まずまずしっかりした土台に見えるね。

(このメモの執筆時点では)未マージな pull-req [\#132](https://github.com/fosslinux/live-bootstrap/pull/132) は、途中で Linux-libre カーネルをビルドしてそこに kexec した上でビルドを続けるような変更らしい。
こいつは楽しみだ。
一方で、 kexec を使わない現状のビルド手順には Linux への依存ってたぶん少ないはずで、 x64 ABI かつ POSIX なカーネルならどこでも走れるんじゃないだろうか？
README には「 \[Linux ではない]他の小さな POSIX カーネルを使うために作業が進行中」って書かれてるし。
ということで、この pull-req をマージするとシードのカーネルに kexec サポートが当然必須になるし、移植性とリッチな機能はなかなか両立しないねー、と。

追記: このメモを最初に公開した翌日(2021-09-14)に[マージされた](https://github.com/fosslinux/live-bootstrap/pull/132#event-5297084411) ってよ。

## 信頼を信頼すること

- https://twitter.com/tenpoku1000/status/1429734151704309764
- https://twitter.com/tenpoku1000/status/1429735268517498887

というリプライがついているけど、「これらの懸念は、強く関係するが隣接する別のプロジェクトの関心事だ」というのが俺の理解。
かの trusting trust attack の巧妙なところは、バイナリシードを監査しない限りソースコードをどれだけ読んでもバックドアを排除できたと確信できないところで。
定番の GNU ビルドシステムをそのまま使うならバイナリシードが~250 MB なんて監査なんて実質的に不可能な大きさになるよ、という点が Guix なり Mes なり live-bootstrap の問題視するところ。
でっかいバイナリブロブの監査をしなきゃならんことに比べれば、ブートストラップの過程にパッケージ・ソースコードが多少増えるのは容認できる取引だろう、と俺は思うね。
困難は分割しましょう: ブートストラップを達成する信頼の鎖ができたら、(なんなら今できてる部分からでも、)大量のソースコードと数百バイトの hex0 をみんなで手分けして監査しましょーね。

## 別のブートストラップ経路？

この live-bootstrap へというよりは、基盤の stage0-posix に向けたアイディアだけど。
ここまで見てきた stage0-posix + mes-m2 では C 言語の処理系まわりを3回も作り直している:

- マクロアセンブリ M0 で書かれた最小限のコンパイラ `cc_*`
- (`cc_*` がサポートする最小限の) C で書かれた M2-Planet
- (M2-Planet がサポートするサブセットの) C で書かれた mes-m2

さて、 Scheme から M0 へのコンパイラを Lisp で書けばこの経路を短縮できないだろうか？
現状だと、 Knight アーキテクチャ向けの M0 だけで書かれた Lisp インタプリタの `stage0/stage2/lisp.s` がすでにあるので、これが残りの各アーキテクチャに移植されると想定する。
`cc_*` と lisp.s はいずれも M0 で書かれているから同じステージで使えるわけだけど、 C と Lisp では後者のほうが言語処理系の開発には使いやすいと個人的には思う。
(まあ、既存のコードには C で書かれたものがだいぶ多そうな気もする。)

このアイディアでは Scheme の全機能までは必要なくて、 MesCC を走らせられればそれでよい。
まず M0 で lisp.s をコンパイルし、次にこの Scheme コンパイラで MesCC を M0 にコンパイルする。
すべてがうまくいけば、その次はもう、ここで作ったネイティブな MesCC で改変 tcc のコンパイルに取りかかれるはずだ。
